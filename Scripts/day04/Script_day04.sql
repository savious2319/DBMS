--day04
-- 키 설정하기
-- 여러개의 PRIMARY KEY

--꽃과 화분

		CREATE TABLE BUYER(
			ID VARCHAR2(20),
			NAME VARCHAR2(20),
			ADDRESS VARCHAR2(30),
			EMAIL VARCHAR2(20),
			CONSTRAINT BUYER_PK PRIMARY KEY(ID)
		);
	
		CREATE TABLE FLOWER(
			FNAME VARCHAR2(20),
			FCOLOR VARCHAR2(10),
			PRICE NUMBER(10),
			CONSTRAINT PK_FNAME PRIMARY KEY(FNAME)
		);
	
		CREATE TABLE FPOT(
			PRODUCT_NUMBER NUMBER(5),
			PCOLOR VARCHAR2(20),
			PSHAPE VARCHAR2(10),
			FNAME VARCHAR2(20),
			CONSTRAINT FK_FNAME_FPOT FOREIGN KEY(FNAME) REFERENCES FLOWER(FNAME),
			CONSTRAINT PK_PRODUCT_NUMBER PRIMARY KEY(PRODUCT_NUMBER) 
		);
	
		CREATE TABLE PURCHASE(
			ID VARCHAR2(20),
			ORDER_NUMBER NUMBER(5),
			PRODUCT_NUMBER NUMBER(5),
			FNAME VARCHAR2(20),
			ADDRESS VARCHAR2(30),
			CONSTRAINT PK_ORDER_NUMBER PRIMARY KEY(ORDER_NUMBER, ID, FNAME, PRODUCT_NUMBER),
			CONSTRAINT FK_PURCHASE_ID FOREIGN KEY(ID)
				REFERENCES BUYER(ID),
			CONSTRAINT FK_PRODUCT_NUMBER FOREIGN KEY(PRODUCT_NUMBER)
				REFERENCES FPOT(PRODUCT_NUMBER),
			CONSTRAINT FK_FNAME_PURCHASE FOREIGN KEY(FNAME)
				REFERENCES FLOWER(FNAME)
		); 

ALTER TABLE PURCHASE DROP PRIMARY KEY;

ALTER TABLE PURCHASE ADD CONSTRAINT PK_PURCHASE PRIMARY KEY(ID, ORDER_NUMBER, PRODUCT_NUMBER, FNAME);

ALTER TABLE PURCHASE ADD(

BUYER_NAME VARCHAR2(20) NOT NULL,
REFUND CHAR(1),
SUPER_ID VARCHAR2(20) CONSTRAINT PURCHASE_PK PRIMARY KEY

);
	
ALTER TABLE MEMBER RENAME TO BUYER; 
ALTER TABLE BUYER MODIFY EMAIL VARCHAR2(30);	

INSERT INTO BUYER VALUES('840910-1042014', 'BRIAN', 'SEOUL, KOREA', 'koreanbradpitt@gmail.com');
INSERT INTO BUYER VALUES('570203-2030324', 'LAKE', 'SEOUL, KOREA', 'lakehae@gmail.com');

SELECT * FROM BUYER;

INSERT INTO FLOWER VALUES('ROSE', 'WHITE', 5000);
INSERT INTO FLOWER VALUES('LILY', 'YELLOW', 6000);
INSERT INTO FLOWER VALUES('TULIP', 'PURPLE', 7000);
	
SELECT * FROM FLOWER;

INSERT INTO FPOT VALUES('23198', 'BROWN', 'SQUARE', 'ROSE');
INSERT INTO FPOT VALUES('23199', 'BLUE', 'TRIANGLE', 'LILY');
INSERT INTO FPOT VALUES('23200', 'GREEN', 'RECTANGLE', 'TULIP');

SELECT * FROM FPOT; 

INSERT INTO PURCHASE VALUES('840910-1042014', '2319', '23200', 'TULIP', 'SEOUL, KOREA');
INSERT INTO PURCHASE VALUES('570203-2030324', '2320', '23200', 'TULIP', 'TOKYO, JAPAN');

SELECT * FROM PURCHASE;

TRUNCATE TABLE FLOWER;
TRUNCATE TABLE FPOT;
TRUNCATE TABLE PURCHASE;

DROP TABLE PURCHASE;	
DROP TABLE FLOWER;
DROP TABLE BUYER;
DROP TABLE FPOT;

	
--dual
SELECT 2354*989757456745 FROM DUAL;

--시간 보기 : sysdate 함수 (영어단어뒤에 소괄호가 없는 형태)
SELECT SYSDATE FROM DUAL;

--alias
SELECT SYSDATE as 현재시간 FROM DUAL;
--만약에 별칭(alias)에 공백이 있을 때는, 쌍따옴표로 묶어 주면된다.
select sysdate "오늘 시간과 날짜" from dual;

select
	sysdate -1000 "1000일 전",
	sysdate "오늘 날짜",
	sysdate + 1000 "1000일 후",
	sysdate + 48/24 "2일 후", --24시간
	sysdate + 3/24 "3시간 후"
from
	dual;

--근무 개월 수 체크 : MONTH_BETWEEN(A, B) A, B 날짜 사이의 "개월수"를 구한다
SELECT ENAME, SYSDATE "금일", MONTHS_BETWEEN(SYSDATE, HIREDATE) FROM EMP;

--※ 소수점이 발생한다.. 소수점을 없애는 함수 TRUC(값)

SELECT ENAME, SYSDATE "금일", 
	TRUNC(MONTHS_BETWEEN(SYSDATE, HIREDATE)) 개월수 
FROM EMP;

--SELECT TRUNC(10/3, 자리값) FROM EMP; --정수부만!!!
SELECT TRUNC(10/3, 2) FROM EMP; --정수부만!!!

SELECT 
	
	ENAME "이름",
	TRUNC(MONTHS_BETWEEN(SYSDATE, HIREDATE) / 12) "근속 년수"

FROM EMP;


--날짜를 기본 출력 형식과 다른 형태로 출력하고 싶다.
--형식 지정, 'YYYY-MM-DD' FORMAT
SELECT SYSDATE, TO_CHAR(SYSDATE, 'YYYY-MM-DD') FROM DUAL;


--날짜 + 시간 형식 +요일까지
SELECT SYSDATE, TO_CHAR(SYSDATE, 'YYYY-MM-DD HH:MI:SS') FROM EMP;

--요일까지
SELECT SYSDATE, TO_CHAR(SYSDATE, 'YYYY-MM-DD DAY HH:MI:SS') FROM EMP;

--고용일이 19801217 인 직원이 있다!
--이 고용일 정보를 조건으로 이름과 고용일을 보고싶다.
SELECT ENAME, HIREDATE FROM EMP 
WHERE HIREDATE = TO_DATE(19801217, 'YYYYMMDD'); --정수든 문자열이든 상관없다

--emp 테이블에서... job이 clerk인 사람을 모두 찾아라.
SELECT * FROM EMP WHERE JOB = 'CLERK';

--EMP 테이블에서 매니저가 7902인 사람의 직원번호, 이름, job 을 출력할 것
SELECT EMPNO, ENAME, JOB FROM EMP WHERE MGR = 7902;



--예제) 
--숫자 조건 : EMP 테이블에서 SAL이 1500이상인 사원의 정보를 조회
SELECT * FROM EMP WHERE SAL > 1500;

--문자 조건 : 이름이 KING인 사람 조회
SELECT * FROM EMP WHERE ENAME = 'KING';

--날짜 조건 : 81/02/20 이전에 입사한 사람들을 조회
SELECT * FROM EMP WHERE HIREDATE < TO_DATE('1981-02-20', 'YYYY-MM-DD');
SELECT * FROM EMP WHERE HIREDATE < '81-02-20';--TO_DATE('1981-02-20', 'YYYY-MM-DD'); 자동형변환

--비교 : 부서번호가 30번이 "아닌" 사람들의 모든 정보를 조회
SELECT * FROM EMP WHERE DEPTNO != 30;

--비교+논리 : 부서번호가 30이고 급여가 2000 이상인 사원들의 사원이름과 급여, 부서번호를 조회
SELECT ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 30 AND SAL > 2000;

--논리 : 직업이 MANAGER가 아닌 사람들 조회
SELECT * FROM EMP WHERE JOB != 'MANAGER';

--비교+논리 : 부서번호가 10번이거나 20번인 사람들의 부서번호와 사원이름을 조회 (IN 사용)
SELECT DEPTNO, ENAME FROM EMP WHERE DEPTNO IN(10,20); --WHERE DEPTNO=10 OR DEPTNO=20;

--SQL 연산자 : 급여가 1000이상 3000이하의 사원들을 조회 (BETWEEN)
SELECT * FROM EMP WHERE SAL BETWEEN 1000 AND 3000;

--SQL 연산자 : 사원이름이 'J'로 시작하는 사원의 사원번호와 이름을 조회(LIKE)
SELECT EMPNO, ENAME FROM EMP WHERE ENAME LIKE 'J%' --J로 시작해야 된다!! J로 시작하는 문자열

--SQL 연산자 : 사원이름이 'T'를 포함하는 사원의 정보를 조회
SELECT * FROM EMP WHERE ENAME LIKE '%T%';  --%문자% 문자열에 T를 포함하고 있는...

--SQL 연산자 : 사원이름 2번째 글자가 'A'인 사원 조회 (LIKE) --글자 하나를 카운트 할때는 _밑줄 하나
SELECT * FROM EMP WHERE ENAME LIKE '_A%'; --첫번째가 아닌 두번째 그래서 _밑줄을 쓴다 처음에

--SQL 연산자 : 81년도에 입사한 사원을 조회 (LIKE)
SELECT * FROM EMP WHERE HIREDATE LIKE '%81%'; --형변환 없이 실행 되는지 확인해 보자!!!

--SQL 연산자 : 커미션이 NULL인 사원들 조회
SELECT * FROM EMP WHERE COMM IS NULL;

--결합 연산자 : 컬럼과 문자열을 결합한다. || 연산자 사용
SELECT ENAME || '의 급여는' || SAL || '입니다' FROM EMP;




CREATE TABLE INFO(
		
		ID_NO NUMBER(4),
		NAME VARCHAR2(10),
		JOB VARCHAR2(9),
		BUNHO NUMBER(4)
		);

INSERT INTO INFO (ID_NO, NAME, JOB, BUNHO)
		SELECT EMPNO, ENAME, JOB, MGR FROM EMP
		WHERE JOB = 'CLERK';

SELECT * FROM INFO;
DROP TABLE INFO;

--실습] 부서번호가 20인 사람들을 모두 찾아서... 이름을 SUPERMAN으로 변경
	UPDATE EMP_TEST SET
		ENAME = 'SUPERMAN'
	WHERE DEPTNO = 20;
SELECT * FROM EMP_TEST;

--실습] 이름에 A가 들어가는 사람들 찾아 'A-MAN'으로 변경해 주세요
		UPDATE EMP_TEST SET
		ENAME = 'A-MAN'
	WHERE ENAME LIKE '%A%';


--실습] 이름에 A가 들어가는 사람을 찾아.. 현재이름 + '-TAG' 을 붙여주세요.
	UPDATE EMP_TEST SET
		ENAME = ENAME || '-TAG'
	WHERE ENAME LIKE '%A%';	



TRUNCATE TABLE EMP_TEST; 

INSERT INTO EMP_TEST SELECT * FROM EMP

--실습] 부서 번호 10인 사람들 삭제하기
-- 다시 INSERT 문장 실행해서 데이터 삽입하기!!! 루틴 반복!!!!
	DELETE FROM EMP_TEST
	WHERE DEPTNO = 10;

	INSERT INTO EMP_TEST
	SELECT * FROM EMP WHERE DEPTNO = 10;

--실습] 81/02/20 이전에 입사한 사람들 삭제하기
-- 방금 삭제한 데이터 다시 삽입해 놓기!!!
	DELETE FROM EMP_TEST
	WHERE HIREDATE < '81/02/20';--TO_DATE(81/02/20, 'YY/MM/DD');

	INSERT INTO EMP_TEST
	SELECT * FROM EMP WHERE HIREDATE < '81/02/20';

SELECT * FROM EMP_TEST;





-----------------------------------------------------------------------------------
--1. 부서번호가 10번인 부서의 사람중 사원번호, 이름,월급을 출력하여라. 
SELECT EMPNO, ENAME, SAL FROM EMP WHERE DEPTNO = 10;

--2. 사원번호가 7369인 사람중 이름,입사일,부서번호를 출력하라.
SELECT ENAME, HIREDATE, DEPTNO FROM EMP WHERE EMPNO = 7369;

--3. 이름이 ALLEN 인 사람의 모든 정보를 출력하라.
SELECT * FROM EMP WHERE ENAME = 'ALLEN';

--4. 입사일이 81/05/01인 사원의 이름,부서번호,월급을 출력하라.
SELECT ENAME, DEPTNO, SAL FROM EMP WHERE HIREDATE = '81/05/01';--TO_DATE('1981-05-01', 'YYYY-MM-DD');
SELECT ENAME, DEPTNO, SAL FROM EMP WHERE TO_CHAR(HIREDATE, 'YYYY/MM/DD') = '1981/05/01';

--TO_DATE('1981-05-01', 'YYYY-MM-DD');
SELECT ename,deptno,sal FROM EMP WHERE TO_DATE(HIREDATE,'YY/MM/DD') = TO_Date('81/05/01','YY/MM/DD');

--5. 직업이 MANAGER 가 아닌 사람의 모든 정보를 출력하라.
SELECT * FROM EMP WHERE JOB != 'MANAGER';

--6. 입사일이 81/04/02 이후에 입사한 사원의 정보를 출력하라.
SELECT * FROM EMP WHERE HIREDATE > '81/04/02';--TO_DATE('1981/04/02', 'YYYY/MM/DD'); 

--7. 급여가 $800 이상인 사람의 이름,급여,부서번호를 출력하라.
SELECT ENAME, SAL, DEPTNO FROM EMP WHERE SAL > 800;

--8. 부서번호가 20번 이상인 사원의 모든 정보를 출력하라.
SELECT * FROM EMP WHERE DEPTNO > 20;

--9. 입사일이 81/12/09 보다 먼저 입사한 사람들의 모든 정보를 출력하라.
SELECT * FROM EMP WHERE HIREDATE < '81/12/09';--TO_DATE('81/12/09', 'YY/MM/DD'); 

--10. 입사번호가 7698 보다 작거나 같은 사람들의 입사번호와 이름을 출력하라.
SELECT EMPNO, ENAME FROM EMP WHERE EMPNO <= 7698;

--11. 입사일이 81/04/02 보다 늦고 82/12/09 보다 빠른 사원의 이름,월급,부서번호,입사번호를 출력하라.
SELECT HIREDATE, ENAME, SAL, DEPTNO, EMPNO FROM EMP 
WHERE TO_DATE(HIREDATE, 'YY/MM/DD') BETWEEN TO_DATE('81/04/02', 'YY/MM/DD') AND TO_DATE('82/12/09', 'YY/MM/DD'); 

SELECT HIREDATE, ENAME, SAL, DEPTNO, EMPNO FROM EMP
WHERE HIREDATE BETWEEN '81/04/02' AND '82/12/09';

--12. 급여가 1,600 보다 크고, $3,000 보다 작은 사람의 이름,직업,급여를 출력하라.
SELECT ENAME, JOB, SAL FROM EMP WHERE SAL > 1600 AND SAL < 3000;


--13. 이름이 B와 J사이의 모든 사원의 이름을 출력하라.
SELECT ENAME FROM EMP WHERE ENAME BETWEEN 'B' AND 'J';


--14. 입사일이 81년 이외에 입사한 사람의 입사일과 이름을 출력하라.
SELECT HIREDATE, ENAME FROM EMP WHERE HIREDATE NOT LIKE '%81%'; 
SELECT HIREDATE, ENAME FROM EMP WHERE HIREDATE < '81/01/01' AND HIREDATE < '82/01/01';
SELECT HIREDATE, ENAME FROM EMP WHERE TO_CHAR(HIREDATE, 'YYYY') != '1981';

--15. 직업이 MANAGER와 SALESMAN인 사람의 이름과 직업을 출력하라.
SELECT ENAME, JOB FROM EMP WHERE JOB = 'MANAGER' OR JOB = 'SALESMAN';
SELECT ENAME, JOB FROM EMP WHERE JOB IN('MANAGER', 'SALESMAN');


--16. 부서번호가 20,30 번을 제외한 모든 사람의 이름,사원번호,부서번호를 출력하라.
SELECT ENAME, EMPNO, DEPTNO FROM EMP WHERE DEPTNO != 20 AND DEPTNO != 30;


--17. 이름이 S로 시작하는 사원의 사원번호,이름,입사일,부서번호를 출력하라
SELECT EMPNO, ENAME, HIREDATE, DEPTNO FROM EMP WHERE ENAME LIKE 'S%';


--18. 입사일이 81년도인 사람의 입사일,이름을 출력하라
SELECT HIREDATE, ENAME FROM EMP WHERE HIREDATE LIKE '%81%';


--19. 이름 중 A자가 들어가 있는 사람만 입사번호,이름을 출력하라.
SELECT EMPNO, ENAME FROM EMP WHERE ENAME LIKE '%A%';


--20. 이름이 S로 시작하고 마지막 글자가 H인 사람의 이름을 출력하라.
SELECT ENAME FROM EMP WHERE ENAME LIKE 'S%H';


--21. 이름의 두번째 문자가 A인 사람의 이름을 출력하라.
SELECT ENAME FROM EMP WHERE ENAME LIKE '_A%';


--22. 커미션이 NULL인 사람의 이름과 커미션을 출력하라.
SELECT ENAME, COMM FROM EMP WHERE COMM IS NULL;


--23. 커미션이 NULL인 아닌 사람의 이름과 커미션을 출력하라.
SELECT ENAME, COMM FROM EMP WHERE COMM IS NOT NULL;


--24. 부서번호가 30번 부서이고,급여가 1500 이상인 사람의 이름,부서번호,월급을 출력하라.
SELECT ENAME, DEPTNO, SAL FROM EMP WHERE DEPTNO = 30 AND SAL > 1500;


--25. 이름의 첫 글자가 K로 시작하거나 부서번호가 30인 사람의 사원번호,이름,부서번호를 출력하라.
SELECT EMPNO, ENAME, DEPTNO FROM EMP WHERE ENAME LIKE 'K%' OR DEPTNO = 30;


--26. 급여가 1500 이상이고,부서번호가 30번인 사원중 직업이 MANAGER인 사람의 급여,부서번호,직업을 출력하라.
SELECT SAL, DEPTNO, JOB FROM EMP WHERE SAL > 1500 AND DEPTNO = 30 AND JOB = 'MANAGER';


--27. 부서번호가 30인 사람의 이름,사원번호,부서번호를 사원번호로 오름정렬하여라.
SELECT ENAME, EMPNO, DEPTNO FROM EMP WHERE DEPTNO = 30 ORDER BY EMPNO ASC;


--28. 이름과 급여의 데이터를 급여가 많은 순으로 정렬하라.
SELECT ENAME, SAL FROM EMP ORDER BY SAL DESC;


--29. 부서번호로 오름차순 정렬한후 급여가 많은 사람순으로 이름,부서번호,급여를 출력하라.
SELECT ENAME, DEPTNO, SAL FROM EMP ORDER BY DEPTNO ASC, SAL DESC;


--30. 부서번호를 내림차순 정렬한후 ,직업순으로 오름정렬,급여순으로 내림정렬하여라.
SELECT * FROM EMP ORDER BY DEPTNO DESC, JOB ASC, SAL DESC;
